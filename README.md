Два ендпоинта в UsersController, один создает юзера, другой запрашивает из БД

## 1. Запуск только сервиса
Сервис можно запустить командой
```
mvn jetty:run
```
При этом отработает jetty-maven-plugin указанный в pom.xml, там все настройки по умолчанию. 
Мавен соберет проект, запустит web-контейнер jetty и запустит собранный проект в этом jetty.
Сплошная магия (

При этом надо указать где установлена монга ДБ в проперти app.mongodb.uri

## 2. Сборка докер образа сервиса
Что бы собрать сервис в докер образ, надо выполнить команду, где rom/mongodemo-service - это просто имя твоего образа
```
docker build -t rom/mongodemo-service .
```
Все данные для сборки образа указаны в Dockerfile.

Я сам не очень понимаю как это работате в деталян, но в общем так:

- FROM maven:3.6.0-jdk-11-slim AS build - взять из репозитория образов образ мавена с джавой 11 
- COPY src /home/app/src  - скопировать исходинки всего проекта из папки src в папку будущего контейнера /home/app/src
- COPY pom.xml /home/app  - конечно для мавен проекта надо скопировать pom.xml
- CMD mvn -f /home/app/pom.xml jetty:run   - зпустить мавен проект, произойдет все то же самое что и в п.1, только теперь внутри контейнера

## 3. Запуск образа сервиса
После того как ты удачно собрал докер образ, он будет храниться у тебя где-то локально, я хз где именно, и это нигоко не интересует, главно что докер теперь знает где искать образ с именем rom/mongodemo-service

Теперь можно смело запускать контейнер в докере
```
docker run -p 8080:8080 rom/mongodemo-service 
```
Дело в том, что образы в контейнере - полностью изолированы от внешнего мира и друг от друга и хотя наш сервис открывает порт 8080, он все равно не будет доступен, т.к. он запущен в изолированной среде, 
но нам же надо как-то до них достучаться, для этого мы указываем докеру что хотим порт 8080 образа прокинуть на 8080 реального порта
-p 8080:8080 

## 4. Запуск образа монги
Ты говорил что установил монгу локально, а можно было одной командой запустить образ могни в контейнере 
```
docker run -p 27017:27017 mongo
```
как видишь, тут мы то же указываем что порт из контейнера хотим прокинуть на реальный внешний порт

Теперь, мы можем запустить монгу командой выше и сервис командой из п.2

## 5. Docker-composer
А теперь самый шик - запустить оба сервиса (контейнера) одной командой. 
Может быть тебе и не надо будет запускать монгу в контейре, но на примере монги тут, ты сможешь потом запустить все свои микросервисы.
Команда запуска всех контейнеров через докер компосер элементарная
```
docker-compose up
```
что бы остановить
```
docker-compose stop
```
Все данные для запуска образов указаны в docker-compose.yml

Тут я то же плохо шарю, но в большем должно быть интуитивно понятно. 
Самое сложное тут опять бороться с изолированием. Тут то же указано что надо порты пробрасывать наружу
```
ports:
- "27017:27017"
```
хотя, мне кажется порт 27017 можно было и не прокидывать наружу, ведь он нужен только сервису который так же внутри контейнера.
Но дело усложняется тем что сервисы не могут друг другу обращаться, ведь они не доступны пол lacalhost как это было ранее. 
Не знаю точно как лучше, но сервисы могут достучаться друг до друга по имени вместо хоста, т.е. монга будет доступна по mongodb:27017.
В Сервисе я захардкодил порт, а хост меняется в параметре app.mongodb.uri (см. п.1), а в docker-compose.yml я переопределил этот параметр\
```
APP_MONGODB_URI: mongodb
```
последнее мне было очень неочевидно, зачем надо было точки менять на ниженее подчеркивание я ХЗ.

